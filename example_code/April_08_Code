#include <Wire.h>
#include <MPU6050.h>
#include <Servo.h>

#define triggerPinLeft 11
#define echoPinLeft 2

#define triggerPinFront 13
#define echoPinFront 3

const int liftFanPin = 5;
const int thrustFanPin = 6;

const int servoPin = 9;
Servo myServo;

const int threshold_front = 20;
const int threshold_side = 20;

int value_front = 0;
int value_side = 0;

// MPU object
MPU6050 mpu;
// variables to store IMU data
float gyroX = 0.0;
float gyroY = 0.0;
float gyroZ = 0.0;
float accelX = 0.0;
float accelY = 0.0;
float accelZ = 0.0;

struct AccelData {
  int16_t x;
  int16_t y;
  int16_t z;
};

struct GyroData {
  int16_t x;
  int16_t y;
  int16_t z;
};

// variable to store the reference angle for stabilization
float refAngle = 0.0;

// Function prototypes
float getDistance(int triggerPin, int echoPin);
float getAngle();
void stabilize();

void setup() {
 
  pinMode(triggerPinLeft, OUTPUT);
  pinMode(echoPinLeft, INPUT);

  pinMode(triggerPinFront, OUTPUT);
  pinMode(echoPinFront, INPUT);

  digitalWrite(liftFanPin, LOW);
  digitalWrite(thrustFanPin, LOW);

  myServo.attach(servoPin);
  myServo.write(90);

  Wire.begin();
  mpu.initialize();
  refAngle = getAngle(); // Get the initial reference angle
}

void loop() {
  digitalWrite(liftFanPin, HIGH);
  analogWrite(thrustFanPin, 135  ); // Set the thrust fan speed to maximum
  //stabilize(); // Call the stabilize function

  value_front = getDistance(triggerPinFront, echoPinFront);
  if (value_front < threshold_front) {
    digitalWrite(liftFanPin, LOW);
    delay(500);
    value_side = getDistance(triggerPinLeft, echoPinLeft);
    if (value_side > threshold_side) { //to turn left
      digitalWrite(liftFanPin, HIGH);
      while ( value_front < 50){
          myServo.write(30);
          value_front = getDistance(triggerPinFront, echoPinFront);
      }
      myServo.write(90); // Stop the servo
    }
    else if (value_side < threshold_side){ //turn right
      digitalWrite(liftFanPin, HIGH);
      while ( value_front < 50){
          myServo.write(150);
          value_front = getDistance(triggerPinFront, echoPinFront);
      }
      myServo.write(90); // Stop the servo
    }
    else {
      myServo.write(90);
    }
  }
}

// Function to calculate the distance from the ultrasonic sensor
float getDistance(int triggerPin, int echoPin) {
  long duration, distance;

  digitalWrite(triggerPin, LOW);
  delayMicroseconds(2);
  digitalWrite(triggerPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(triggerPin, LOW);

  duration = pulseIn(echoPin, HIGH);
  distance = (duration / 2) * 0.0343;
  return distance;
}

// Function to calculate the reference angle for stabilization
float getAngle() {
  // Read the accelerometer values
  AccelData accel;
  mpu.getAcceleration(&accel.x, &accel.y, &accel.z);

  // Calculate the angle using the x and z components of the accelerometer values
  float angle = atan2(accel.y, accel.z) * 180.0 / PI;

  return angle;
}

// Function to stabilize the hovercraft using the servo motor
void stabilize() {
  // Read the gyro values
  GyroData gyro;
  mpu.getRotation(&gyro.x, &gyro.y, &gyro.z);

  // Convert the raw gyro rate to degrees per second
  float gyroRate = gyro.y / 131.0;

  // Calculate the error between the current angle and the reference angle
  float error = getAngle() - refAngle;

  // Calculate the correction value for the servo motor
  float servoCorrection = error * 0.05 + gyroRate * 0.05;

  // Apply the correction value to the servo motor
  int servoValue = 90 - (int)(servoCorrection * 2.0);
  if (servoValue < 0) {
    servoValue = 0;
  }
  else if (servoValue > 180) {
    servoValue = 180;
  }
  myServo.write(servoValue);
}

 
